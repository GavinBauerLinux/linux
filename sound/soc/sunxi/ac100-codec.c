// SPDX-License-Identifier: GPL-2.0
/*
 * This driver supports the controls for X-Powers (Allwinner)
 * AC100 audio codec. This codec is co-packaged with AXP81x PMICs.
 *
 * (C) Copyright 2017-2019 Ondrej Jirman <megous@megous.com>
 */

#define DEBUG

// TODO:
// - chip reset on probe / remove
// - setup pll
//   - source, dividion factors, enable
// - setup system clock

#include <linux/module.h>
#include <linux/delay.h>
#include <linux/io.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <linux/regmap.h>
#include <linux/mfd/ac100.h>

#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/tlv.h>

#include "ac100-regs.h"

// {{{ Reasearch

/*
 * Reasearch
 * ---------
 *
 * Features:
 * 2 A/D
 * 2 D/A
 * 2 I2S/PCM #1 and #2
 * 1 PCM mono #3 muxable with I2S #2
 * 3 mic inputs (mic #2 and #3 exclusively muxable at input)
 * 1 line in (directly or through amp)
 * 1 aux input
 * all input signals mixable directly into output (bypass AD/DA)
 *
 * outputs:
 * HPOUTL     - headphone left
 * HPOUTR     - headphone right
 * LINEOUT    - line out differential
 * EAROUT     - earpeiece differential
 * SPKOUT1    - SPOL left speaker differnetial
 * SPKOUT2    - SPOR right speaker differnetial
 *
 * Power up:
 * LDOIN      - 1.5-3.3V external power
 * AVCC       - analog power 3V
 * CPVDD      - 1.8V
 * VDD-IO1    - power for I2S #1 and #2   1.8/3V
 * VDD-IO2    - power for I2S #3  1.8/3V
 * VCC-RTC    - power for RTC 1.8/3V
 *
 * Clocks: page 28
 * SYSCLK must be 24576000 Hz (48kHz) or 22579200 Hz (44.1kHz)
 *   - Source I2S1CLK/MCLK1
 *   - If SRC# module is used SYSCLK must be generated by PLL
 *
 * A/D:
 * ADC_APC_CTRL B15 B11 enable/disable A/D to save power
 * ADC_APC_CTRL B14-12 B10-8 volume control for A/D
 * ADC_DIG_CTRL B15 enable/disable digital A/D to save power
 * ADDA_FS_I2S1 ADDA_FS_I2S2 - select sample rate
 *
 * D/A:
 * OMIXER_DACA_CTRL B15-14  enable/disable D/A channels
 * DAC_DIG_CTRL B15 enable/disable digital D/A
 *
 * Mixer:
 * - 2 channels DAC Output mixers
 *   - inputs:
 *      - LINEINL/R
 *      - AXIL/R
 *      - MIC1P/N,MIC2P/N
 *      - Stereo DAC output
 * - 2 channels ADC Record mixers
 *   - inputs:
 *      - LINEINL/R
 *      - AXIL/R
 *      - MIC1P/N,MIC2P/N
 *      - Stereo DAC output
 * - Digital mixers
 *   - avaliable on:
 *     - before stereo DAC - DAC_MXR_SRC
 *     - I2S1 output - I2S1_MXR_SRC
 *     - I2S2 output - I2S2_MXR_SRC
 * - Analogue inputs
 *   - LINEINL/R - 1 ch. mono
 *     - can be mixed into ADC record mixer or DAC output mixer
 *     - -9dB to 12dB in 1.5dB step by LINEIN_DIFF_PREG
 *   - AXIL/R - 2 ch. stereo
 *     - can be mixed into ADC record mixer or DAC output mixer
 *     - programmable volume level adj. and mute
 *       - -9dB to 12dB in 1.5dB steps by AXI_PREG
 *   - MIC1P/N - has preamp
 *   - MIC2P/N - has preamp
 *   - MIC3P/N - has preamp muxed with MIC2 (sel by ADC_SRCBST_CTRL B7)
 *     - can be mixed into ADC record mixer or DAC output mixer
 *     - preamps enable at ADC_SRCBST_CTRL B15 and B11
 *       - preamp gain at MIC1BOOST MIC2BOOST
 * - Analogue outputs:
 *   - HPOUTL/R, HPOUTFB - 2ch. headphones
 *     - sources output mixer or directly from DAC
 *       - sel HPOUT_CTRL B15 B14
 *       - mute HPOUT_CTRL B13 B12
 *     - power amp
 *       - powerdown/up HPOUT_CTRL B11
 *     - volume HP_VOL[5:0] - 64dB range in 1dB step from 0dB to -62dB
 *       - mute by using 0 for HP_VOL[5:0]
 *     - DC offset cancellation (POP noise) HP_DCRM_EN
 *       - This bit must be set 0xf before headphone PA enabled, and this bit
 *         must be set 0x0 before headphone PA disabled.
 *     - zero cross to prevent noise/clicsk on volume change ZCROSS_EN
 *   - SPOLP/N, SPORP/N 2 ch. speakers (mono/stereo)
 *     - source for SPOLP
 *       - left output mixer or (left+right) output mixer
 *     - source for SPORP
 *       - right output mixer or (left+right) output mixer
 *     - volume 43.5dB rang in 1.5dB step from -43.5dB to 0dB
 *     - amp enable SPKOUT_CTRL B11 B7
 *   - EAROUTP/N - 1 ch earpeice
 *     - source left DAC, right DAC, left output mixer or right output mixer
 *     - volume ERPOUT_CTRL[4:0] 43.5dB range in 1.5dB step from -43.5dB to 0dB
 *     - power amp enable ERPOUT_CTRL B5
 *   - LINEOUTP/N - 1ch line out
 *     - source MIC1 preamp, MIC2 preamp, left output mix or right output mix
 *     - volume 10.5dB range in 1.5dB step from -4.5dB to 6dB
 *     - out buffer power up/down LOUT_CTRL B4
 *
 * Jack insert detection:
 * - HBIAS current detection
 *   - 5bit ADC sample rate 16/32/64/128Hz
 *   - HMIC_STATUS[12:8] - ADC value
 *   - 2 thresholds TH1 for plug connection, TH2 for key press
 *   - can periodically trigger interrupts during key press (HBIAS above TH2)
 *
 * Interrupts:
 * - FALLING_EDGE
 * - for:
 *   - KEYDOWN
 *   - KEYUP
 *   - PLUG_IN
 *   - PLUG_OUT
 *   - HMIC_DATA
 *
 * High Pass Filter:
 * - remove DC offset, can be disabled
 *
 * AGC:
 * - automatic gain control before ADC input channels
 * - params:
 *   - attack, decay time - 32/fs to 2^15*32/fs
 *   - target gain - –1dB to –30dB relative to a full-scale signal
 *   - noise threshold - –30dB to –90dB of full-scale (mute if input below this level)
 *   - max gain 0dB to 40dB in steps of 0.5dB
 *   - hysteresis - for noise detection in terms of signal level
 *   - debounce time - hysteresis for noise det in terms of time
 * - also provides some output flags:
 *   - noise threshold reached
 *   - current gain
 *   - agc saturated (gain could get higher for the given input, but limited by
 *		      params)
 *   - adc saturated - clipping at ADC input stage
 *
 * DRC:
 * - dynamic range control for digital playback path
 *   - energy filter
 *   - compressor
 *   - smooth filter
 * - can be disabled
 */

// }}}
// {{{ Driver data

#define AC100_NUM_SUPPLIES 5

struct ac100_codec {
	struct device	*dev;
	struct regmap	*regmap;
	int		irq;

	unsigned long   sysclk_rate;
	struct regulator_bulk_data supplies[AC100_NUM_SUPPLIES];
};

static const char *const ac100_supply_names[AC100_NUM_SUPPLIES] = {
	"LDOIN",
	"AVCC",
	"CPVDD",
	"VDD_IO1",
	"VDD_IO2",
};

// }}}
// {{{ Codec widgets and routes

#if 0
static const struct snd_kcontrol_new ac100_dac_mixer_controls[] = {
	SOC_DAPM_DOUBLE("AIF1 Slot 0 Digital DAC Playback Switch",
			AC100_DAC_MXR_SRC,
			AC100_DAC_MXR_SRC_DACL_MXR_SRC_AIF1DA0L,
			AC100_DAC_MXR_SRC_DACR_MXR_SRC_AIF1DA0R, 1, 0),
	SOC_DAPM_DOUBLE("AIF1 Slot 1 Digital DAC Playback Switch",
			AC100_DAC_MXR_SRC,
			AC100_DAC_MXR_SRC_DACL_MXR_SRC_AIF1DA1L,
			AC100_DAC_MXR_SRC_DACR_MXR_SRC_AIF1DA1R, 1, 0),
	SOC_DAPM_DOUBLE("AIF2 Digital DAC Playback Switch", AC100_DAC_MXR_SRC,
			AC100_DAC_MXR_SRC_DACL_MXR_SRC_AIF2DACL,
			AC100_DAC_MXR_SRC_DACR_MXR_SRC_AIF2DACR, 1, 0),
	SOC_DAPM_DOUBLE("ADC Digital DAC Playback Switch", AC100_DAC_MXR_SRC,
			AC100_DAC_MXR_SRC_DACL_MXR_SRC_ADCL,
			AC100_DAC_MXR_SRC_DACR_MXR_SRC_ADCR, 1, 0),
};

/*
static const struct snd_kcontrol_new ac100_input_mixer_controls[] = {
	SOC_DAPM_DOUBLE("AIF1 Slot 0 Digital ADC Capture Switch",
			AC100_AIF1_MXR_SRC,
			AC100_AIF1_MXR_SRC_AD0L_MXL_SRC_AIF1DA0L,
			AC100_AIF1_MXR_SRC_AD0R_MXR_SRC_AIF1DA0R, 1, 0),
	SOC_DAPM_DOUBLE("AIF2 Digital ADC Capture Switch", AC100_AIF1_MXR_SRC,
			AC100_AIF1_MXR_SRC_AD0L_MXL_SRC_AIF2DACL,
			AC100_AIF1_MXR_SRC_AD0R_MXR_SRC_AIF2DACR, 1, 0),
	SOC_DAPM_DOUBLE("AIF1 Data Digital ADC Capture Switch",
			AC100_AIF1_MXR_SRC,
			AC100_AIF1_MXR_SRC_AD0L_MXL_SRC_ADCL,
			AC100_AIF1_MXR_SRC_AD0R_MXR_SRC_ADCR, 1, 0),
	SOC_DAPM_DOUBLE("AIF2 Inv Digital ADC Capture Switch",
			AC100_AIF1_MXR_SRC,
			AC100_AIF1_MXR_SRC_AD0L_MXL_SRC_AIF2DACR,
			AC100_AIF1_MXR_SRC_AD0R_MXR_SRC_AIF2DACL, 1, 0),
};
  */
#endif

#if 0

static const DECLARE_TLV_DB_SCALE(aif1_ad_slot0_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif1_ad_slot1_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif1_da_slot0_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif1_da_slot1_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif1_ad_slot0_mix_vol_tlv, -600, 600, 0);
static const DECLARE_TLV_DB_SCALE(aif1_ad_slot1_mix_vol_tlv, -600, 600, 0);

static const DECLARE_TLV_DB_SCALE(aif2_ad_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif2_da_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(aif2_ad_mix_vol_tlv, -600, 600, 0);

static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -11925, 75, 0);
static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -11925, 75, 0);

static const DECLARE_TLV_DB_SCALE(dig_vol_tlv, -7308, 116, 0);
static const DECLARE_TLV_DB_SCALE(dac_mix_vol_tlv, -600, 600, 0);
static const DECLARE_TLV_DB_SCALE(adc_input_vol_tlv, -450, 150, 0);

static const DECLARE_TLV_DB_SCALE(axin_to_l_r_mix_vol_tlv, -450, 150, 0);
static const DECLARE_TLV_DB_SCALE(mic1_to_l_r_mix_vol_tlv, -450, 150, 0);
static const DECLARE_TLV_DB_SCALE(mic2_to_l_r_mix_vol_tlv, -450, 150, 0);
static const DECLARE_TLV_DB_SCALE(linein_to_l_r_mix_vol_tlv, -450, 150, 0);
#endif

static const DECLARE_TLV_DB_RANGE(ac100_codec_mic_boost_scale,
	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
	1, 7, TLV_DB_SCALE_ITEM(3000, 300, 0),
);

static const DECLARE_TLV_DB_SCALE(ac100_codec_aux_linein_boost_scale,
				  -1200, 300, 0);

static const DECLARE_TLV_DB_RANGE(ac100_codec_mic_boost_scale,
	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
	1, 7, TLV_DB_SCALE_ITEM(3000, 300, 0),
);

static const DECLARE_TLV_DB_RANGE(ac100_codec_earpiece_speaker_vol_tlv,
	0, 1, TLV_DB_SCALE_ITEM(0, 0, 0),
	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 0),
);

static const DECLARE_TLV_DB_SCALE(ac100_codec_lineout_vol_tlv, -450, 150, 0);

static const DECLARE_TLV_DB_RANGE(ac100_codec_headphone_vol_tlv,
	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
	1, 63, TLV_DB_SCALE_ITEM(-6200, 100, 0),
);

static const struct snd_kcontrol_new ac100_codec_controls[] = {
	/* Input analog amplifier gain controls */
	SOC_SINGLE_TLV("MIC1 PGA Gain", AC100_ADC_SRC_BST_CTRL,
		       AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF, 0x7, 0,
		       ac100_codec_mic_boost_scale),
	SOC_SINGLE_TLV("MIC2 PGA Gain", AC100_ADC_SRC_BST_CTRL,
		       AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF, 0x7, 0,
		       ac100_codec_mic_boost_scale),
	SOC_SINGLE_TLV("AUXIN PGA Gain", AC100_ADC_SRC_BST_CTRL,
		       AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF, 0x7, 0,
		       ac100_codec_aux_linein_boost_scale),
	SOC_SINGLE_TLV("LINEIN PGA Gain", AC100_ADC_SRC_BST_CTRL,
		       AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF, 0x7, 0,
		       ac100_codec_aux_linein_boost_scale),

	/* Output analog amplifiers gain controls */
	SOC_SINGLE_TLV("EAROUT Volume", AC100_ERPOUT_CTRL,
		       AC100_ERPOUT_CTRL_VOLUME_OFF, 0x1f, 0,
		       ac100_codec_earpiece_speaker_vol_tlv),
	SOC_SINGLE_TLV("SPOUT Volume", AC100_SPKOUT_CTRL,
		       AC100_SPKOUT_CTRL_VOLUME_OFF, 0x1f, 0,
		       ac100_codec_earpiece_speaker_vol_tlv),
	SOC_SINGLE_TLV("LINEOUT Volume", AC100_LINEOUT_CTRL,
		       AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF, 0x7, 0,
		       ac100_codec_lineout_vol_tlv),
	SOC_SINGLE_TLV("HPOUT Volume", AC100_HPOUT_CTRL,
		       AC100_HPOUT_CTRL_VOLUME_OFF, 0x3f, 0,
		       ac100_codec_headphone_vol_tlv),

	/* Digital volume controls */

#if 0
	/*AIF1*/
	SOC_DOUBLE_TLV("AIF1 ADC timeslot 0 volume", AIF1_VOL_CTRL1, AIF1_AD0L_VOL, AIF1_AD0R_VOL, 0xff, 0, aif1_ad_slot0_vol_tlv),
	SOC_DOUBLE_TLV("AIF1 ADC timeslot 1 volume", AIF1_VOL_CTRL2, AIF1_AD1L_VOL, AIF1_AD1R_VOL, 0xff, 0, aif1_ad_slot1_vol_tlv),
	SOC_DOUBLE_TLV("AIF1 DAC timeslot 0 volume", AIF1_VOL_CTRL3, AIF1_DA0L_VOL, AIF1_DA0R_VOL, 0xff, 0, aif1_da_slot0_vol_tlv),
	SOC_DOUBLE_TLV("AIF1 DAC timeslot 1 volume", AIF1_VOL_CTRL4, AIF1_DA1L_VOL, AIF1_DA1R_VOL, 0xff, 0, aif1_da_slot1_vol_tlv),
	SOC_DOUBLE_TLV("AIF1 ADC timeslot 0 mixer gain", AIF1_MXR_GAIN, AIF1_AD0L_MXR_GAIN, AIF1_AD0R_MXR_GAIN, 0xf, 0, aif1_ad_slot0_mix_vol_tlv),
	SOC_DOUBLE_TLV("AIF1 ADC timeslot 1 mixer gain", AIF1_MXR_GAIN, AIF1_AD1L_MXR_GAIN, AIF1_AD1R_MXR_GAIN, 0x3, 0, aif1_ad_slot1_mix_vol_tlv),

	/*AIF2*/
	SOC_DOUBLE_TLV("AIF2 ADC volume", AIF2_VOL_CTRL1, AIF2_ADCL_VOL,AIF2_ADCR_VOL, 0xff, 0, aif2_ad_vol_tlv),
	SOC_DOUBLE_TLV("AIF2 DAC volume", AIF2_VOL_CTRL2, AIF2_DACL_VOL,AIF2_DACR_VOL, 0xff, 0, aif2_da_vol_tlv),
	SOC_DOUBLE_TLV("AIF2 ADC mixer gain", AIF2_MXR_GAIN, AIF2_ADCL_MXR_GAIN,AIF2_ADCR_MXR_GAIN, 0xf, 0, aif2_ad_mix_vol_tlv),

	/*ADC*/
	SOC_DOUBLE_TLV("ADC volume", ADC_VOL_CTRL, ADC_VOL_L, ADC_VOL_R, 0xff, 0, adc_vol_tlv),
	/*DAC*/
	SOC_DOUBLE_TLV("DAC volume", DAC_VOL_CTRL, DAC_VOL_L, DAC_VOL_R, 0xff, 0, dac_vol_tlv),
	SOC_DOUBLE_TLV("DAC mixer gain", DAC_MXR_GAIN, DACL_MXR_GAIN, DACR_MXR_GAIN, 0xf, 0, dac_mix_vol_tlv),

	SOC_SINGLE_TLV("digital volume", DAC_DBG_CTRL, DVC, 0x3f, 0, dig_vol_tlv),

	/*ADC*/
	SOC_DOUBLE_TLV("ADC input gain", ADC_APC_CTRL, ADCLG, ADCRG, 0x7, 0, adc_input_vol_tlv),

	SOC_SINGLE_TLV("LINEINL-LINEINR pre-amplifier gain", ADC_SRCBST_CTRL, LINEIN_PREG, 0x7, 0, linein_amp_vol_tlv),

	SOC_SINGLE_TLV("AXin to L_R output mixer gain", OMIXER_BST1_CTRL, AXG, 0x7, 0, axin_to_l_r_mix_vol_tlv),
	SOC_SINGLE_TLV("MIC1 BST stage to L_R outp mixer gain", OMIXER_BST1_CTRL, OMIXER_MIC1G, 0x7, 0, mic1_to_l_r_mix_vol_tlv),
	SOC_SINGLE_TLV("MIC2 BST stage to L_R outp mixer gain", OMIXER_BST1_CTRL, OMIXER_MIC2G, 0x7, 0, mic2_to_l_r_mix_vol_tlv),
	SOC_SINGLE_TLV("LINEINL/R to L_R output mixer gain", OMIXER_BST1_CTRL, LINEING, 0x7, 0, linein_to_l_r_mix_vol_tlv),

#endif
};

/* Input */

static const char * const ac100_codec_mic2slt_txt[] = {
	"MIC2", "MIC3"
};

static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2slt_enum,
			    AC100_ADC_SRC_BST_CTRL,
			    AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF,
			    2, ac100_codec_mic2slt_txt);

static const struct snd_kcontrol_new ac100_codec_mic2_pga_input_select =
	SOC_DAPM_ENUM("MIC2 PGA Input Select", ac100_codec_mic2slt_enum);

/* Output */

static const char *ac100_hp_r_func_sel[] = {
	"DACR HPR Switch", "Right Analog Mixer HPR Switch"
};

static SOC_ENUM_SINGLE_DECL(ac100_hp_r_func_enum, HPOUT_CTRL, RHPS, 2, ac100_hp_r_func_sel);

static const struct snd_kcontrol_new ac100_hp_r_func_controls =
	SOC_DAPM_ENUM("HP_R Mux", ac100_hp_r_func_enum);

static const char *ac100_hp_l_func_sel[] = {
	"DACL HPL Switch", "Left Analog Mixer HPL Switch"
};

static SOC_ENUM_SINGLE_DECL(ac100_hp_l_func_enum, HPOUT_CTRL, LHPS, 2, ac100_hp_l_func_sel);

static const struct snd_kcontrol_new ac100_hp_l_func_controls =
	SOC_DAPM_ENUM("HP_L Mux", ac100_hp_l_func_enum);


static const char *ac100_rspks_func_sel[] = {
	"MIXER Switch", "MIXR MIXL Switch"};
static const struct soc_enum ac100_rspks_func_enum =
	SOC_ENUM_SINGLE(SPKOUT_CTRL, RSPKS, 2, ac100_rspks_func_sel);

static const struct snd_kcontrol_new ac100_rspks_func_controls =
	SOC_DAPM_ENUM("SPK_R Mux", ac100_rspks_func_enum);

static const char *ac100_lspks_l_func_sel[] = {
	"MIXEL Switch", "MIXL MIXR  Switch"};
static const struct soc_enum ac100_lspks_func_enum =
	SOC_ENUM_SINGLE(SPKOUT_CTRL, LSPKS, 2, ac100_lspks_l_func_sel);

static const struct snd_kcontrol_new ac100_lspks_func_controls =
	SOC_DAPM_ENUM("SPK_L Mux", ac100_lspks_func_enum);


/*earpiece source select*/
static const char *ac100_earpiece_func_sel[] = {
	"DACR", "DACL", "Right Analog Mixer", "Left Analog Mixer"};
static const struct soc_enum ac100_earpiece_func_enum =
	SOC_ENUM_SINGLE(ESPKOUT_CTRL, ESPSR, 4, ac100_earpiece_func_sel);

static const struct snd_kcontrol_new ac100_earpiece_func_controls =
	SOC_DAPM_ENUM("EAR Mux", ac100_earpiece_func_enum);

static const struct snd_soc_dapm_widget ac100_codec_dapm_widgets[] = {

	/* Analog Inputs: */
	SND_SOC_DAPM_INPUT("MIC1"),
	SND_SOC_DAPM_INPUT("MIC2"),
	SND_SOC_DAPM_INPUT("MIC3"),

	SND_SOC_DAPM_MUX("MIC2 PGA Input Mux", SND_SOC_NOPM, 0, 0,
			 &ac100_codec_mic2_pga_input_select),

	/* Microphone/line-in pre-amp */
	SND_SOC_DAPM_PGA("MIC1 PGA", AC100_ADC_SRC_BST_CTRL,
			 AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF, 0, NULL, 0),
	SND_SOC_DAPM_PGA("MIC2 PGA", AC100_ADC_SRC_BST_CTRL,
			 AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF, 0, NULL, 0),

	SND_SOC_DAPM_INPUT("LINEIN"),
	SND_SOC_DAPM_INPUT("AUXINR"),
	SND_SOC_DAPM_INPUT("AUXINL"),

	/* TODO: line in is either differential or stereo input (via a switch) */

	/* TODO: all inputs can be mixed into analog output directly */

	/* Microphone bias */
	SND_SOC_DAPM_MICBIAS("MBIAS", AC100_ADC_APC_CTRL,
			     AC100_ADC_APC_CTRL_MBIAS_EN_OFF, 0),
	SND_SOC_DAPM_MICBIAS("HBIAS", AC100_ADC_APC_CTRL,
			     AC100_ADC_APC_CTRL_HBIAS_EN_OFF, 0),

	SND_SOC_DAPM_MIXER_E("LEFT ADC input Mixer", ADC_APC_CTRL, ADCLEN, 0,
		ac100_ladcmix_controls, ARRAY_SIZE(ac100_ladcmix_controls),late_enable_adc, SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),
	SND_SOC_DAPM_MIXER_E("RIGHT ADC input Mixer", ADC_APC_CTRL, ADCREN, 0,
		ac100_radcmix_controls, ARRAY_SIZE(ac100_radcmix_controls),late_enable_adc, SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),
	/* Digital parts of the DACs and ADC */
	SND_SOC_DAPM_SUPPLY("DAC", AC100_DAC_DIG_CTRL,
                            AC100_DAC_DIG_CTRL_DA_EN_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("ADC", AC100_ADC_DIG_CTRL,
                            AC100_ADC_DIG_CTRL_DIG_EN_OFF, 0, NULL, 0),

	/* Analog DAC AIF */
	//SND_SOC_DAPM_AIF_IN("AIF1 Slot 0 Left", "Playback", 0,
			    //AC100_AIF1_DACDAT_CTRL,
			    //AC100_AIF1_DACDAT_CTRL_AIF1_DA0L_ENA, 0),
	//SND_SOC_DAPM_AIF_IN("AIF1 Slot 0 Right", "Playback", 0,
			    //AC100_AIF1_DACDAT_CTRL,
			    //AC100_AIF1_DACDAT_CTRL_AIF1_DA0R_ENA, 0),

	/* Analog ADC AIF */
	//SND_SOC_DAPM_AIF_IN("AIF1 Slot 0 Left ADC", "Capture", 0,
			    //AC100_AIF1_ADCDAT_CTRL,
			    //AC100_AIF1_ADCDAT_CTRL_AIF1_DA0L_ENA, 0),
	//SND_SOC_DAPM_AIF_IN("AIF1 Slot 0 Right ADC", "Capture", 0,
			    //AC100_AIF1_ADCDAT_CTRL,
			    //AC100_AIF1_ADCDAT_CTRL_AIF1_DA0R_ENA, 0),

	/* DAC and ADC Mixers */
	//SOC_MIXER_ARRAY("Left Digital DAC Mixer", SND_SOC_NOPM, 0, 0,
			//ac100_dac_mixer_controls),
	//SOC_MIXER_ARRAY("Right Digital DAC Mixer", SND_SOC_NOPM, 0, 0,
			//ac100_dac_mixer_controls),

	//SOC_MIXER_ARRAY("Left Digital ADC Mixer", SND_SOC_NOPM, 0, 0,
			//ac100_input_mixer_controls),
	//SOC_MIXER_ARRAY("Right Digital ADC Mixer", SND_SOC_NOPM, 0, 0,
			//ac100_input_mixer_controls),

	//SND_SOC_DAPM_MIC("Headset Mic", NULL),
	//SND_SOC_DAPM_MIC("Mic", NULL),

	SND_SOC_DAPM_MIXER("Left Output Mixer", AC100_OUT_MXR_SRC_B``,
			   SUN8I_ADDA_DAC_PA_SRC_LMIXEN, 0,
			   sun8i_codec_mixer_controls,
			   ARRAY_SIZE(sun8i_codec_mixer_controls)),
	SND_SOC_DAPM_MIXER("Right Output Mixer", SUN8I_ADDA_DAC_PA_SRC,
			   SUN8I_ADDA_DAC_PA_SRC_RMIXEN, 0,
			   sun8i_codec_mixer_controls,
			   ARRAY_SIZE(sun8i_codec_mixer_controls)),

	SND_SOC_DAPM_MIXER("Left Input Mixer", SUN8I_ADDA_ADC_AP_EN,
			   SUN8I_ADDA_ADC_AP_EN_ADCLEN, 0,
			   sun8i_codec_adc_mixer_controls,
			   ARRAY_SIZE(sun8i_codec_adc_mixer_controls)),
	SND_SOC_DAPM_MIXER("Right Input Mixer", SUN8I_ADDA_ADC_AP_EN,
			   SUN8I_ADDA_ADC_AP_EN_ADCREN, 0,
			   sun8i_codec_adc_mixer_controls,
			   ARRAY_SIZE(sun8i_codec_adc_mixer_controls)),
	/* */
	SND_SOC_DAPM_MUX("HP_R Mux", SND_SOC_NOPM, 0, 0,	&ac100_hp_r_func_controls),
	SND_SOC_DAPM_MUX("HP_L Mux", SND_SOC_NOPM, 0, 0,	&ac100_hp_l_func_controls),

	SND_SOC_DAPM_MUX("SPK_R Mux", SPKOUT_CTRL, RSPK_EN, 0,	&ac100_rspks_func_controls),
	SND_SOC_DAPM_MUX("SPK_L Mux", SPKOUT_CTRL, LSPK_EN, 0,	&ac100_lspks_func_controls),

        /* Outputs: */
	SND_SOC_DAPM_OUTPUT("SPOUTL"),
	SND_SOC_DAPM_OUTPUT("SPOUTR"),
	SND_SOC_DAPM_OUTPUT("HPOUTL"),
	SND_SOC_DAPM_OUTPUT("HPOUTR"),
	SND_SOC_DAPM_OUTPUT("EAROUT"),
	SND_SOC_DAPM_OUTPUT("LINEOUT"),

	/* Clocks/Resets */
	SND_SOC_DAPM_SUPPLY("MODCLK I2S1", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_I2S1_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK I2S2", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_I2S2_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK I2S3", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_I2S3_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK SRC1", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_SRC1_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK SRC2", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_SRC2_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK HPF AGC", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_HPF_AGC_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK HPF DRC", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_HPF_DRC_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK DAC", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_DAC_DIGITAL_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("MODCLK ADC", AC100_MOD_CLK_ENA,
			    AC100_MOD_CLK_ENA_ADC_DIGITAL_OFF, 0, NULL, 0),

	SND_SOC_DAPM_SUPPLY("RST I2S1", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_I2S1_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST I2S2", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_I2S2_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST I2S3", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_I2S3_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST SRC1", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_SRC1_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST SRC2", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_SRC2_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST HPF AGC", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_HPF_AGC_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST HPF DRC", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_HPF_DRC_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST DAC", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_DAC_DIGITAL_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("RST ADC", AC100_MOD_RST_CTRL,
			    AC100_MOD_RST_CTRL_ADC_DIGITAL_OFF, 0, NULL, 0),

	SND_SOC_DAPM_SUPPLY("SYSCLK I2S1", AC100_SYSCLK_CTRL,
			    AC100_SYSCLK_CTRL_I2S1CLK_ENA_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("SYSCLK I2S2", AC100_SYSCLK_CTRL,
			    AC100_SYSCLK_CTRL_I2S2CLK_ENA_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("SYSCLK", AC100_SYSCLK_CTRL,
			    AC100_SYSCLK_CTRL_SYSCLK_ENA_OFF, 0, NULL, 0),
	SND_SOC_DAPM_SUPPLY("PLL CLK", AC100_SYSCLK_CTRL,
			    AC100_SYSCLK_CTRL_PLLCLK_ENA_OFF, 0, NULL, 0),

	/* Inversion as 0=AIF1, 1=AIF2 */
	//SND_SOC_DAPM_SUPPLY("SYSCLK AIF1", AC100_SYSCLK_CTL,
			    //AC100_SYSCLK_CTL_SYSCLK_SRC, 1, NULL, 0),

};

static const struct snd_soc_dapm_route ac100_codec_dapm_routes[] = {
	/* Reset Routes */
	{ "MODCLK I2S1", NULL, "RST I2S1" },
	{ "MODCLK I2S2", NULL, "RST I2S2" },
	{ "MODCLK I2S3", NULL, "RST I2S3" },
	{ "MODCLK SRC1", NULL, "RST SRC1" },
	{ "MODCLK SRC2", NULL, "RST SRC2" },
	{ "MODCLK HPF AGC", NULL, "RST HPF AGC" },
	{ "MODCLK HPF DRC", NULL, "RST HPF DRC" },
	{ "MODCLK DAC", NULL, "RST DAC" },
	{ "MODCLK ADC", NULL, "RST ADC" },

	/* Clock Routes */
	{ "AIF1", NULL, "SYSCLK I2S1" },
	{ "AIF1 PLL", NULL, "AIF1" },
	{ "RST AIF1", NULL, "AIF1 PLL" },
	{ "DAC", NULL, "MODCLK AFI1" },
	{ "ADC", NULL, "MODCLK AFI1" },

	{ "RST DAC", NULL, "SYSCLK" },
	{ "MODCLK DAC", NULL, "RST DAC" },
	{ "DAC", NULL, "MODCLK DAC" },

	{ "RST ADC", NULL, "SYSCLK" },
	{ "MODCLK ADC", NULL, "RST ADC" },
	{ "ADC", NULL, "MODCLK ADC" },

	/* DAC Routes */
	{ "AIF1 Slot 0 Right", NULL, "DAC" },
	{ "AIF1 Slot 0 Left", NULL, "DAC" },

	/* DAC Mixer Routes */
	{ "Left Digital DAC Mixer", "AIF1 Slot 0 Digital DAC Playback Switch",
	  "AIF1 Slot 0 Left"},
	{ "Right Digital DAC Mixer", "AIF1 Slot 0 Digital DAC Playback Switch",
	  "AIF1 Slot 0 Right"},

	/* ADC Routes */
	{ "AIF1 Slot 0 Right ADC", NULL, "ADC" },
	{ "AIF1 Slot 0 Left ADC", NULL, "ADC" },

	/* ADC Mixer Routes */
	{ "Left Digital ADC Mixer", "AIF1 Data Digital ADC Capture Switch",
	  "AIF1 Slot 0 Left ADC" },
	{ "Right Digital ADC Mixer", "AIF1 Data Digital ADC Capture Switch",
	  "AIF1 Slot 0 Right ADC" },
};

static int ac100_set_component_sysclk(struct snd_soc_component *component,
		int clk_id, int source, unsigned int freq, int dir)
{
	struct ac100_codec *codec = snd_soc_component_get_drvdata(component);
	unsigned int reg_val = 0;

	/*
	if (freq == rt1305->sysclk && clk_id == rt1305->sysclk_src)
		return 0;

	switch (clk_id) {
	case RT1305_FS_SYS_PRE_S_MCLK:
		reg_val |= RT1305_SEL_FS_SYS_PRE_MCLK;
		snd_soc_component_update_bits(component,
			RT1305_CLOCK_DETECT, RT1305_SEL_CLK_DET_SRC_MASK,
			RT1305_SEL_CLK_DET_SRC_MCLK);
		break;
	case RT1305_FS_SYS_PRE_S_PLL1:
		reg_val |= RT1305_SEL_FS_SYS_PRE_PLL;
		break;
	case RT1305_FS_SYS_PRE_S_RCCLK:
		reg_val |= RT1305_SEL_FS_SYS_PRE_RCCLK;
		break;
	default:
		dev_err(component->dev, "Invalid clock id (%d)\n", clk_id);
		return -EINVAL;
	}
	snd_soc_component_update_bits(component, RT1305_CLK_1,
		RT1305_SEL_FS_SYS_PRE_MASK, reg_val);
	rt1305->sysclk = freq;
	rt1305->sysclk_src = clk_id;
          */

	dev_dbg(component->dev, "Sysclk is %dHz and clock id is %d\n",
		freq, clk_id);

	return 0;
}

static int ac100_set_component_pll(struct snd_soc_component *component,
		int pll_id, int source, unsigned int freq_in,
		unsigned int freq_out)
{
	struct ac100_codec *codec = snd_soc_component_get_drvdata(component);
	unsigned int reg_val = 0;
	int ret;

#if 0
	if (source == rt1305->pll_src && freq_in == rt1305->pll_in &&
	    freq_out == rt1305->pll_out)
		return 0;

	if (!freq_in || !freq_out) {
		dev_dbg(component->dev, "PLL disabled\n");

		rt1305->pll_in = 0;
		rt1305->pll_out = 0;
		snd_soc_component_update_bits(component, RT1305_CLK_1,
			RT1305_SEL_FS_SYS_PRE_MASK | RT1305_SEL_PLL_SRC_1_MASK,
			RT1305_SEL_FS_SYS_PRE_PLL | RT1305_SEL_PLL_SRC_1_BCLK);
		return 0;
	}

	switch (source) {
	case RT1305_PLL2_S_MCLK:
		snd_soc_component_update_bits(component, RT1305_CLK_1,
			RT1305_SEL_PLL_SRC_2_MASK | RT1305_SEL_PLL_SRC_1_MASK |
			RT1305_DIV_PLL_SRC_2_MASK,
			RT1305_SEL_PLL_SRC_2_MCLK | RT1305_SEL_PLL_SRC_1_PLL2);
		snd_soc_component_update_bits(component,
			RT1305_CLOCK_DETECT, RT1305_SEL_CLK_DET_SRC_MASK,
			RT1305_SEL_CLK_DET_SRC_MCLK);
		break;
	case RT1305_PLL1_S_BCLK:
		snd_soc_component_update_bits(component,
			RT1305_CLK_1, RT1305_SEL_PLL_SRC_1_MASK,
			RT1305_SEL_PLL_SRC_1_BCLK);
		break;
	case RT1305_PLL2_S_RCCLK:
		snd_soc_component_update_bits(component, RT1305_CLK_1,
			RT1305_SEL_PLL_SRC_2_MASK | RT1305_SEL_PLL_SRC_1_MASK |
			RT1305_DIV_PLL_SRC_2_MASK,
			RT1305_SEL_PLL_SRC_2_RCCLK | RT1305_SEL_PLL_SRC_1_PLL2);
		freq_in = 98304000;
		break;
	default:
		dev_err(component->dev, "Unknown PLL Source %d\n", source);
		return -EINVAL;
	}

	ret = rl6231_pll_calc(freq_in, freq_out, &pll_code);
	if (ret < 0) {
		dev_err(component->dev, "Unsupport input clock %d\n", freq_in);
		return ret;
	}

	dev_dbg(component->dev, "bypass=%d m=%d n=%d k=%d\n",
		pll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),
		pll_code.n_code, pll_code.k_code);

	snd_soc_component_write(component, RT1305_PLL1_1,
		(pll_code.m_bp ? 0 : pll_code.m_code) << RT1305_PLL_1_M_SFT |
		pll_code.m_bp << RT1305_PLL_1_M_BYPASS_SFT |
		pll_code.n_code);
	snd_soc_component_write(component, RT1305_PLL1_2,
		pll_code.k_code);

	rt1305->pll_in = freq_in;
	rt1305->pll_out = freq_out;
	rt1305->pll_src = source;
#endif

	return 0;
}

static const struct snd_soc_component_driver ac100_soc_component = {
	//.probe = rt1305_probe,
	//.remove = rt1305_remove,
	//.suspend = rt1305_suspend,
	//.resume = rt1305_resume,

	//.set_sysclk = ac100_set_component_sysclk,
	//.set_pll = ac100_set_component_pll,

	.controls		= ac100_codec_controls,
	.num_controls		= ARRAY_SIZE(ac100_codec_controls),
	.dapm_widgets		= ac100_codec_dapm_widgets,
	.num_dapm_widgets	= ARRAY_SIZE(ac100_codec_dapm_widgets),
	.dapm_routes		= ac100_codec_dapm_routes,
	.num_dapm_routes	= ARRAY_SIZE(ac100_codec_dapm_routes),
	.idle_bias_on		= 1,
	.use_pmdown_time	= 1,
	.endianness		= 1,
	.non_legacy_dai_naming	= 1,
};

// }}}
// {{{ AC100 dais

static int ac100_codec_get_hw_rate(struct snd_pcm_hw_params *params)
{
	unsigned int rate = params_rate(params);

	switch (rate) {
	case 8000:
	case 7350:
		return 0x0;
	case 11025:
		return 0x1;
	case 12000:
		return 0x2;
	case 16000:
		return 0x3;
	case 22050:
		return 0x4;
	case 24000:
		return 0x5;
	case 32000:
		return 0x6;
	case 44100:
		return 0x7;
	case 48000:
		return 0x8;
	case 96000:
		return 0x9;
	case 192000:
		return 0xa;
	default:
		return -EINVAL;
	}
}

struct ac100_codec_clk_div {
	u8	div;
	u8	val;
};

static const struct ac100_codec_clk_div ac100_codec_bclk_div[] = {
	{ .div = 1,	.val = 0 },
	{ .div = 2,	.val = 1 },
	{ .div = 4,	.val = 2 },
	{ .div = 6,	.val = 3 },
	{ .div = 8,	.val = 4 },
	{ .div = 12,	.val = 5 },
	{ .div = 16,	.val = 6 },
	{ .div = 24,	.val = 7 },
	{ .div = 32,	.val = 8 },
	{ .div = 48,	.val = 9 },
	{ .div = 64,	.val = 10 },
	{ .div = 96,	.val = 11 },
	{ .div = 128,	.val = 12 },
	{ .div = 192,	.val = 13 },
};

static unsigned int ac100_codec_get_bclk_div(struct ac100_codec *codec,
					     unsigned int rate,
					     unsigned int word_size)
{
	unsigned int div = codec->sysclk_rate / rate / word_size / 2;
	unsigned int best_val = 0, best_diff = ~0;
	int i;

	for (i = 0; i < ARRAY_SIZE(ac100_codec_bclk_div); i++) {
		const struct ac100_codec_clk_div *bdiv = &ac100_codec_bclk_div[i];
		unsigned int diff = abs(bdiv->div - div);

		if (diff < best_diff) {
			best_diff = diff;
			best_val = bdiv->val;
		}
	}

	return best_val;
}

static int ac100_codec_get_lrck_div(unsigned int channels,
				    unsigned int word_size)
{
	unsigned int div = word_size * channels;

	if (div < 16 || div > 256)
		return -EINVAL;

	return ilog2(div) - 4;
}

static int ac100_codec_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *params,
				 struct snd_soc_dai *dai)
{
	struct ac100_codec *codec = snd_soc_component_get_drvdata(dai->component);
	int sample_rate, lrck_div;
	unsigned int bclk_div;
	u32 value;

	/*
	 * The CPU DAI handles only a sample of 16 bits. Configure the
	 * codec to handle this type of sample resolution.
	 */
	value = AC100_I2S1_CLK_CTRL_WORD_SIZE_16BIT;

	bclk_div = ac100_codec_get_bclk_div(codec, params_rate(params), 16);
	value |= bclk_div << AC100_I2S1_CLK_CTRL_BCLK_DIV_OFF;

	lrck_div = ac100_codec_get_lrck_div(params_channels(params),
					    params_physical_width(params));
	if (lrck_div < 0)
		return lrck_div;

	value |= lrck_div << AC100_I2S1_CLK_CTRL_LRCK_DIV_OFF;

	sample_rate = ac100_codec_get_hw_rate(params);
	if (sample_rate < 0)
		return sample_rate;

	regmap_update_bits(codec->regmap, AC100_I2S1_CLK_CTRL,
			   AC100_I2S1_CLK_CTRL_WORD_SIZE_MASK |
			   AC100_I2S1_CLK_CTRL_BCLK_DIV_MASK |
			   AC100_I2S1_CLK_CTRL_LRCK_DIV_MASK, value);

	regmap_update_bits(codec->regmap, AC100_I2S_SR_CTRL,
			   AC100_I2S_SR_CTRL_FS_I2S1_MASK,
			   sample_rate << AC100_I2S_SR_CTRL_FS_I2S1_OFF);

	return 0;
}

static int ac100_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
{
	struct ac100_codec *codec = snd_soc_component_get_drvdata(dai->component);
	u32 value = 0;

	/* clock masters */
	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
	case SND_SOC_DAIFMT_CBS_CFS: /* Codec slave, DAI master */
		value |= AC100_I2S1_CLK_CTRL_MSTR_MOD_SLAVE;
		break;
	case SND_SOC_DAIFMT_CBM_CFM: /* Codec Master, DAI slave */
		value |= AC100_I2S1_CLK_CTRL_MSTR_MOD_MASTER;
		break;
	default:
		return -EINVAL;
	}

	/* clock inversion */
	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
	case SND_SOC_DAIFMT_NB_NF: /* Normal */
		value |= AC100_I2S1_CLK_CTRL_BCLK_INV_NORMAL;
		value |= AC100_I2S1_CLK_CTRL_LRCK_INV_NORMAL;
		break;
	case SND_SOC_DAIFMT_IB_IF: /* Inversion */
		value |= AC100_I2S1_CLK_CTRL_BCLK_INV_INVERTED;
		value |= AC100_I2S1_CLK_CTRL_LRCK_INV_INVERTED;
		break;
	default:
		return -EINVAL;
	}

	/* DAI format */
	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
	case SND_SOC_DAIFMT_I2S:
		value |= AC100_I2S1_CLK_CTRL_DATA_FMT_I2S_MODE;
		break;
	case SND_SOC_DAIFMT_LEFT_J:
		value |= AC100_I2S1_CLK_CTRL_DATA_FMT_LEFT_MODE;
		break;
	case SND_SOC_DAIFMT_RIGHT_J:
		value |= AC100_I2S1_CLK_CTRL_DATA_FMT_RIGHT_MODE;
		break;
	case SND_SOC_DAIFMT_DSP_A:
	case SND_SOC_DAIFMT_DSP_B:
		value |= AC100_I2S1_CLK_CTRL_DATA_FMT_DSP_MODE;
		break;
	default:
		return -EINVAL;
	}

	regmap_update_bits(codec->regmap, AC100_I2S1_CLK_CTRL,
			   AC100_I2S1_CLK_CTRL_MSTR_MOD_MASK |
			   AC100_I2S1_CLK_CTRL_BCLK_INV_MASK |
			   AC100_I2S1_CLK_CTRL_LRCK_INV_MASK |
			   AC100_I2S1_CLK_CTRL_DATA_FMT_MASK, value);

	return 0;
}

static const struct snd_soc_dai_ops ac100_codec_dai_ops = {
	.hw_params = ac100_codec_hw_params,
	.set_fmt = ac100_set_fmt,
};

static struct snd_soc_dai_driver ac100_codec_dais[] = {
	{
		.name = "ac100-aif1",
		.id = 1,
		.playback = {
			.stream_name = "AIF1 Playback",
			.channels_min = 1,
			.channels_max = 2,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
		},
		.capture = {
			.stream_name = "AIF1 Capture",
			.channels_min = 1,
			.channels_max = 2,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
//			.sig_bits = 24,
		},
		.ops = &ac100_codec_dai_ops,
	},
	/*
	{
		.name = "ac100-aif2",
		.id = 2,
		.playback = {
			.stream_name = "AIF2 Playback",
			.channels_min = 1,
			.channels_max = 2,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
		},
		.capture = {
			.stream_name = "AIF2 Capture",
			.channels_min = 1,
			.channels_max = 2,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
			.sig_bits = 24,
		},
		.ops = &ac100_codec_dai_ops,
	},
	{
		.name = "ac100-aif3",
		.id = 3,
		.playback = {
			.stream_name = "AIF3 Playback",
			.channels_min = 1,
			.channels_max = 1,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
		},
		.capture = {
			.stream_name = "AIF3 Capture",
			.channels_min = 1,
			.channels_max = 1,
			.rates = SNDRV_PCM_RATE_8000_192000,
			.formats = SNDRV_PCM_FMTBIT_S16_LE,
			.sig_bits = 24,
		},
		.ops = &ac100_codec_dai_ops,
	},
	*/
};

// }}}
// {{{ IRQ handler

#define AC100_USE_IRQ 0

#if AC100_USE_IRQ
static irqreturn_t ac100_codec_irq(int irq, void *data)
{
	struct ac100_codec *codec = data;
	unsigned int val = 0;
	int ret;

	/* read status */
	ret = regmap_read(codec->regmap, AC100_HMIC_STATUS, &val);
	if (ret)
		return IRQ_HANDLED;

	if (val & AC100_HMIC_PULLOUT_PENDING) {
		dev_info(codec->dev, "IRQ: Pull out");
	}

	if (val & AC100_HMIC_PLUGIN_PENDING) {
		dev_info(codec->dev, "IRQ: Plug in");
	}

	if (val & AC100_HMIC_KEYUP_PENDING) {
		dev_info(codec->dev, "IRQ: Key up");
	}

	if (val & AC100_HMIC_KEYDOWN_PENDING) {
		dev_info(codec->dev, "IRQ: Key down");
	}

	if (val & AC100_HMIC_DATA_PENDING) {
		dev_info(codec->dev, "IRQ: Data");
	}

	/* clear status */
	ret = regmap_write(codec->regmap, AC100_HMIC_STATUS, 0);
	if (ret)
		return IRQ_HANDLED;

	return IRQ_HANDLED;
}
#endif

// }}}
// {{{ Probe

static int ac100_codec_probe(struct platform_device *pdev)
{
	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
	struct device* dev = &pdev->dev;
	struct ac100_codec *codec;
	int ret, i;

	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
	if (!codec)
		return -ENOMEM;

	platform_set_drvdata(pdev, codec);
	codec->dev = dev;
	codec->regmap = ac100->regmap;

	for (i = 0; i < ARRAY_SIZE(codec->supplies); i++)
		codec->supplies[i].supply = ac100_supply_names[i];

        ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(codec->supplies),
                                      codec->supplies);
        if (ret != 0) {
		if (ret != -EPROBE_DEFER)
			dev_err(dev, "Failed to request supplies: %d\n", ret);
                return ret;
        }

	ret = devm_snd_soc_register_component(dev, &ac100_soc_component,
				     ac100_codec_dais,
				     ARRAY_SIZE(ac100_codec_dais));
	if (ret) {
		dev_err(dev, "Failed to register codec\n");
		return ret;
	}

#if AC100_USE_IRQ
	codec->irq = platform_get_irq(pdev, 0);
	if (codec->irq < 0) {
		dev_err(dev, "No IRQ resource\n");
		return codec->irq;
	}

	ret = devm_request_threaded_irq(dev, codec->irq, NULL,
					ac100_codec_irq,
					IRQF_SHARED | IRQF_ONESHOT,
					dev_name(dev), codec);
	if (ret) {
		dev_err(dev, "Could not request IRQ\n");
		return ret;
	}
#endif

        ret = regulator_bulk_enable(ARRAY_SIZE(codec->supplies),
                                    codec->supplies);
        if (ret != 0) {
                dev_err(dev, "Failed to enable supplies: %d\n", ret);
                return ret;
        }

        msleep(50);

	// to prevent LDOIN leakage? BSP says so.
	//regmap_update_bits(codec->regmap, ADDA_TUNE3, (0x1<<OSCEN), (0x1<<OSCEN));
	//regmap_write(codec->regmap, DAC_VOL_CTRL, 0);

	return ret;
}

static int ac100_codec_remove(struct platform_device *pdev)
{
	struct snd_soc_card *card = platform_get_drvdata(pdev);
	struct ac100_codec *codec = snd_soc_card_get_drvdata(card);

        regulator_bulk_disable(ARRAY_SIZE(codec->supplies), codec->supplies);

	return 0;
}

static const struct of_device_id ac100_codec_of_match[] = {
	{ .compatible = "x-powers,ac100-codec" },
	{}
};
MODULE_DEVICE_TABLE(of, ac100_codec_of_match);

static struct platform_driver ac100_codec_driver = {
	.driver = {
		.name = "ac100-codec",
		.of_match_table = ac100_codec_of_match,
	},
	.probe = ac100_codec_probe,
	.remove = ac100_codec_remove,
};
module_platform_driver(ac100_codec_driver);

MODULE_DESCRIPTION("X-Powers AC100 codec driver");
MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:ac100-codec");

// }}}
